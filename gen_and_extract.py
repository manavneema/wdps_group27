from llama_cpp import Llama
import spacy
import wikipedia
import warnings
from bs4 import GuessedAtParserWarning
import logging

logging.basicConfig(filename='entity_linker.log', level=logging.INFO,
                    format='%(asctime)s:%(levelname)s:%(message)s')
warnings.filterwarnings("ignore", category=GuessedAtParserWarning)
nlp = spacy.load("en_core_web_sm")
model_path = "models/llama-2-7b.Q4_K_M.gguf"
llm = Llama(model_path=model_path, verbose=False)

# function to extract entities from the given text and returns entity vs url for the text
# source is used to identify either input(question asked to the llm) or output(answer of the LLM)
def extract_and_link_entities(text, source):
    doc = nlp(text)
    entities = [(ent.text, ent.label_) for ent in doc.ents if ent.label_ in ('GPE', 'PERSON', 'ORG')]
    logging.info(f"Extracted Entities from {source}: {entities}")
    linked_entities = []

    for e in entities:
        entity_text = e[0]  # entity name
        logging.info(f'Processing entity: "{entity_text}"')
        try:
            # Fetch the Wikipedia page for the entity
            page = wikipedia.page(entity_text, auto_suggest=False)
            url = page.url
            logging.info(f'URL: {url}')
            linked_entities.append((entity_text, url))
        except wikipedia.DisambiguationError as de:
            print(f'DisambiguationError for "{entity_text}":')
            logging.warning(f'DisambiguationError for "{entity_text}": {de.options}')
            #TODO: look at some other way to handle disambiguation errors
            fallback = de.options[0]
            try:
                page = wikipedia.page(fallback, auto_suggest=False)
                url = page.url
                print(f'Using fallback option "{fallback}". URL: {url}')
                logging.info(f'Using fallback option "{fallback}". URL: {url}')
                linked_entities.append((entity_text, url))
            except Exception as ex:
                print(f'Failed to resolve disambiguation for "{entity_text}". Error: {ex}')
                logging.error(f'Failed to resolve disambiguation for "{entity_text}". Error: {ex}')
        except wikipedia.PageError:
            print(f'PageError: The page for "{entity_text}" does not exist.')
            logging.error(f'PageError: The page for "{entity_text}" does not exist.')
        except Exception as ex:
            print(f'An unexpected error occurred: {ex}')
            logging.error(f'An unexpected error occurred: {ex}')

    return linked_entities

def print_entities(entities):
    for entity, url in entities:
        print(f'{entity}\t{url}')
        logging.info(f'{entity}\t{url}')

def process_question(question_text):
    print(f'Asking the question "{question_text}" to {model_path} (wait, it can take some time...)')
    logging.info(f'Asking the question "{question_text}" to {model_path} (wait, it can take some time...)')

    enhanced_prompt = f"{question_text} Answer:"
    output = llm(
          enhanced_prompt,    
          max_tokens=32,     
          echo=False, #don't echo the question in the response         
          seed=42,
          temperature=0.0,    
          top_p=0.0
    ) #set a seed value for non random output, temperature=0, top_p=0 for minimal variance in output
    # print(output['choices'])
    logging.info(f"LLM Output: {output['choices']}")

    if not output['choices']:
        print("No output generated by the LLM.")
        logging.warning("No output generated by the LLM.")
        return

    # extract the text from the first choice
    llm_output_text = output['choices'][0]['text'].strip()
    if not llm_output_text:
        print("LLM did not generate any response.")
        logging.warning("LLM did not generate any response.")
        return

    print(f'\nProcessed LLM Output: "{llm_output_text}"')
    logging.info(f'Processed LLM Output: "{llm_output_text}"')

    input_entities = extract_and_link_entities(question_text, source='User')
    output_entities = extract_and_link_entities(llm_output_text, source='LLM')
    all_entities = input_entities + output_entities
    unique_entities = {}
    for entity, url in all_entities:
        if entity not in unique_entities:
            unique_entities[entity] = url

    print("\n--- Combined Unique Entities ---")
    logging.info("--- Combined Unique Entities ---")
    print_entities(unique_entities.items())

def main():
    print("Enter your questions below. Type 'exit' or 'quit' to terminate the program.\n")
    logging.info("Program started.")

    question_counter = 1
    while True:
        user_input = input("Enter your question: ").strip()
        if user_input.lower() in ['exit', 'quit']:
            print("Exiting the program. Goodbye!")
            logging.info("Program terminated by user.")
            break

        if not user_input:
            print("Empty input. Please enter a valid question.")
            logging.warning("User entered an empty question.")
            continue

        process_question(user_input)
        print("\n")
        question_counter += 1

if __name__ == "__main__":
    main()